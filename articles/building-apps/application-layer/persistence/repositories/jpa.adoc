---
title: JPA Repositories
description: TODO
order: 20
---

= JPA Repositories

Jakarta Persistence used to be called Java Persistence API, and is still often abbreviated JPA. It is a Java API for managing relational data in Java applications. Since it is an API, you can't do much with JPA alone - you also need a JPA implementation. https://hibernate.org/[Hibernate] is supported by Spring Boot out of the box and is therefore the implementation recommended for Vaadin applications.

The recommended way to implement JPA <<index#,repositories>> is with https://spring.io/projects/spring-data-jpa[Spring Data JPA]. Spring Data JPA is a framework that aims to reduce the amount of boilerplate code needed to write JPA queries.

[NOTE]
This page describes how to build repositories with JPA in Vaadin applications. It assumes you are already familiar with both JPA and Spring Data. If you have not used them before, you should at least read the https://spring.io/guides/gs/accessing-data-jpa[Accessing Data with JPA] guide, and have a quick look at the https://docs.spring.io/spring-data/jpa/reference/index.html[Spring Data JPA documentation] before continuing.

== Repository Interfaces

When using Spring Data JPA, your repository interfaces should extend the `JpaRepository` interface directly. By doing that, you don't have to implement them yourself - Spring Data takes care of that for you. For example, a repository for a `Customer` entity looks like this:

[source,java]
----
import org.springframework.data.jpa.repository.JpaRepository;

public interface CustomerRepository extends JpaRepository<Customer, Long> { // <1>

}
----
<1> The `Long` parameter is the type of the ID, or the primary key, used to identify a single customer.

Spring Data repositories are _persistence oriented_ repositories, but do on some occasions behave like _collection oriented_ ones. This has to do with how JPA works. While an entity is _managed_ by a _persistence context_, any changes made to it are automatically saved to the database when the transaction is committed. This happens regardless of whether you have called the `save` method or not.

When the transaction is committed or rolled back, the entities become _detached_. After this, any changes made to them are no longer saved to the database. For more information about entity states, see the https://docs.jboss.org/hibernate/orm/6.6/introduction/html_single/Hibernate_Introduction.html#persistence-contexts[Hibernate documentation].

Calling the `save` method works regardless of whether the entity is managed or detached. Therefore, you should always call the `save` method if you intend to save the changes. This also makes the code easier to read. However, to avoid strange side effects, you should avoid editing entities inside a transaction if you don't intend to save them.

// TODO Add links to transaction management

== Entities

JPA imposes some restrictions on your entities. The classes themselves cannot be `final`, nor can they contain any `final` fields. Also, they are required to have a default constructor, but this can be package private or protected.

You should add an explicit `@Table` annotation to the entity class, with an explicit table name.

For fields, add explicit `@Column` annotations, with explicit column names.

For joins, use `@JoinColumn` and `@JoinTable`, with explicit table and column names.

All this makes it easier to write <<../flyway#,Flyway migrations>> later.

To make it easier for Spring Data to decide whether an entity is new or persistent, you should implement the `Persistable` interface, like this:

[source,java]
----
import org.springframework.data.domain.Persistable;
...

@Entity
@Table(name = "customers")
public class Customer implements Persistable<Long> {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name = "customer_id")
    private Long id;

    @Override
    public Long getId() {
        return id;
    }

    @Override
    public boolean isNew() {
        return id == null;
    }
}
----

Don't extend the `AbstractPersistable` class. Instead, declare the `@Id` field directly in every entity class, or make your own base class. This gives you better control over how your entity ID:s are generated.

Override `equals` and `hashCode` so that an entity is either equal to itself, or to another entity of the same type with the same ID. If Hibernate generates the ID for you, you should consider that the ID can be `null`:

[source,java]
----
import org.springframework.data.domain.Persistable;
import org.springframework.data.util.ProxyUtils;
...

@Entity
@Table(name = "customers")
public class Customer implements Persistable<Long> {
    ...

// tag::snippet[]
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || !getClass().equals(ProxyUtils.getUserClass(o))) return false;
        Customer customer = (Customer) o;
        return id != null && id.equals(customer.id);
    }

    @Override
    public int hashCode() {
        return Objects.hashCode(id);
    }
// end::snippet[]
}
----

Hibernate can return proxied versions of the entities. Because of this, you cannot directly compare the classes inside `equals`, as a proxied entity would not have the same class as a non-proxied one. To fix this, you can use the `ProxyUtils.getUserClass` utility method provided by Spring.

// TODO Write something about business keys, but that should probably be introduced on its own page first

== Domain Primitives

If you have domain primitives in your entities, you can handle them in two ways. Both ways have their own advantages and disadvantages.
// TODO Link to domain primitives once that page has been reviewed and merged.

=== Accessor Methods

The most straight-forward way of using domain primitives is to use the unwrapped value in the field, and convert to and from the domain primitive in the accessor methods. For example, if you have an `EmailAddress` domain primitive, you could do this:

[source,java]
----
@Entity
@Table(name = "customers")
public class Customer implements Persistable<Long> {
    ...

    @Column(name = "customer_email")
    private String email;

    public EmailAddress getEmail() {
        return email == null ? null : new EmailAddress(email);
    }

    public void setEmail(EmailAddress email) {
        this.email = email == null ? null : email.value();
    }
}
----

This approach also works with multi-value domain primitives. For example, if you have a `MonetaryAmount` domain primitive that consists of a `BigDecimal` and a `CurrencyUnit` enum, you could do this:

[source,java]
----
@Entity
@Table(name = "offers")
public class Offer implements Persistable<Long> {
    ...

    @Enumerated(EnumType.STRING)
    @Column(name = "currency")
    private CurrencyUnit currency;
    
    @Column(name = "price")
    private BigDecimal price;

    // Null-checks have been excluded for brevity

    public MonetaryAmount getPrice() {
        return new MonetaryAmount(currency, price);
    }

    public void setPrice(MonetaryAmount amount) {
        this.currency = amount.currency();
        this.price = amount.value();
    }
}
----

Although the accessor methods require some extra code, this approach makes it easier to write query specifications. Whenever you are doing wildcard queries, range queries, or use aggregate functions, it is much easier to work with the raw types than with custom types.

=== Attribute Converters

You can use single-value domain primitives directly in your fields by writing attribute converters for them. For example, an attribute converter for an `EmailAddress` domain primitive could look like this:

[source,java]
----
import jakarta.persistence.AttributeConverter;
import jakarta.persistence.Converter;

@Converter
public class EmailAddressAttributeConverter implements AttributeConverter<EmailAddress, String> {

    @Override
    public String convertToDatabaseColumn(EmailAddress attribute) {
        return attribute == null ? null : attribute.value();
    }

    @Override
    public EmailAddress convertToEntityAttribute(String dbData) {
        return dbData == null ? null : new EmailAddress(dbData);
    }
}
----

In your entities, you could then use the converter like this:

[source,java]
----
@Entity
@Table(name = "customers")
public class Customer implements Persistable<Long> {
    ...

    @Column(name = "customer_email")
// tag::snippet[]
    @Convert(converter = EmailAddressAttributeConverter.class)
// end::snippet[]
    private EmailAddress email;

    public EmailAddress getEmail() {
        return email;
    }

    public void setEmail(EmailAddress email) {
        this.email = email;
    }
}
----

This approach makes your entity classes much cleaner, but has one drawback. Any query that does not check for equality becomes more difficult to write. 

For example, writing a query that returns customers whose email addresses start or end with a search term would require the `LIKE` operator. If you are writing the query using the https://jakarta.ee/learn/docs/jakartaee-tutorial/current/persist/persistence-criteria/persistence-criteria.html:[JPA Criteria API], the `like` method requires a string, not an `EmailAddress`. And even if it worked with `EmailAddress`, you would not be able to turn the search term into one, since the search term may not contain a complete email address.

Furthermore, attribute converters don't work with primary keys. If you are working with domain-driven design and aggregate roots, you may want to use domain primitives for the ID:s as well. For example, you may want to use a `CustomerId` to refer to a customer rather than a `long`.
// TODO Add links to DDD page once writen

Attribute converters are a good alternative for single-value domain primitives that are not used as identifiers, and only need to be queried by equality. In all other cases, accessor methods is a better choice.

== Query Methods

Spring Data has support for different kinds of query methods in the repository interfaces.
// TODO Continue here. Give a brief overview of the types of query methods you should use in the repositories in a typical Vaadin app.

== Query Specifications

// TODO Criteria API and metamodel generation

== Query Objects

// Read-only repositories